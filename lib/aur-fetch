#!/bin/bash
# aur-fetch - retrieve build files from the AUR
[[ -v AUR_DEBUG ]] && set -o xtrace
readonly argv0=fetch
readonly AUR_LOCATION=${AUR_LOCATION:-https://aur.archlinux.org}
readonly XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[1]}(): }'

# default options
verbose=0 recurse=0 confirm_seen=0 pull_args=('--verbose')

git_clone_set_config() {
    if git clone "$AUR_LOCATION"/"$1".git; then
        # Show PKGBUILDs first. (#399)
        git -C "$1" config diff.orderFile "$2"
        # Only allow fast-forward fetches. (#552)
        git -C "$1" config remote.origin.fetch 'refs/heads/*:refs/remotes/origin/*'
    else
        error '%s: %s: Failed to clone repository' "$argv0" "$1"
        exit 1
    fi
}

usage() {
    cat <<! | base64 -d
ICAgICAgICAgICAgIC4tLX5+LF9fCjotLi4uLiwtLS0tLS0tYH5+Jy5fLicKIGAtLCwsICAs
XyAgICAgIDsnflUnCiAgXywtJyAsJ2AtX187ICctLS4KIChfLyd+fiAgICAgICcnJycoOwoK
!
    plain 'usage: %s [-L directory] [-rv] pkgname...' "$argv0" >&2
    exit 1
}

source /usr/share/makepkg/util/message.sh
source /usr/share/makepkg/util/parseopts.sh

if [[ ! -v NO_COLOR ]] && [[ ! -o xtrace ]]; then
    [[ -t 2 ]] && colorize
fi

opt_short='rvL:'
opt_long=('recurse' 'verbose' 'write-log:' 'force' 'confirm-seen')
opt_hidden=('dump-options')

if ! parseopts "$opt_short" "${opt_long[@]}" "${opt_hidden[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset log_dir
while true; do
    case "$1" in
        -L|--write-log) shift; log_dir=$1 ;;
        -r|--recurse)   recurse=1 ;;
        -v|--verbose)   verbose=1 ;;
        --force)        pull_args+=('--force') ;;
        --confirm-seen) confirm_seen=1 ;;
        --dump-options) printf -- '--%s\n' "${opt_long[@]}" ;
                        printf -- '%s' "${opt_short}" | sed 's/.:\?/-&\n/g' ;
                        exit ;;
        --) shift; break ;;
    esac
    shift
done

if [[ -v $log_dir ]] && [[ ! -d $log_dir ]]; then
    error '%s: %s: Not a directory' "$argv0" "$log_dir"
    exit 20
fi

if ! (( $# )); then
    error '%s: No pkgname given' "$argv0"
    exit 1
fi

if (( confirm_seen )); then
    msg 'Marking repositories as seen'
fi

# Default to showing PKGBUILD first in patch. (#399)
mkdir -p "$XDG_CONFIG_HOME/aurutils/$argv0"
orderfile=$XDG_CONFIG_HOME/aurutils/$argv0/orderfile

if ! [[ -s $orderfile ]]; then
    printf 'PKGBUILD\n' >"$orderfile"
fi

if (( recurse )); then
    aur depends --pkgbase "$@"
else
   printf '%s\n' "$@"
fi | while read -r pkg; do
    if ! [[ -e $pkg ]]; then
        git_clone_set_config "$pkg" "$orderfile"

        if (( confirm_seen )); then
            git update-ref AURUTILS_SEEN HEAD

            warning 'Marked new repository %s as seen' "$pkg"
            continue
        else
            # This case may be handled differently from an existing repo where
            # the AURUTILS_SEEN ref does not exist; here, we know that the repo
            # is at the current HEAD, and a git pull is not required.
            : cloned repository was not inspected
        fi
    else
        # Ensure a valid git repository. (#586)
        if GIT_DIR=$(git rev-parse --resolve-git-dir "$pkg"/.git); then
            # Avoid issues with filesystem boundaries. (#274)
            export GIT_DIR GIT_WORK_TREE=$pkg
        else
            exit 1 # exit 128
        fi

        if (( confirm_seen )); then
            git update-ref AURUTILS_SEEN HEAD

            msg2 'Marked %s as seen' "$pkg"
            continue
        fi

        # Discard any local uncommited changes. (#552)
        git reset --hard HEAD >&2

        if ! git pull --rebase "${pull_args[@]}"; then
            error '%s: Failed to integrate changes.' "$pkg"
            exit 1
        fi
        
        # TODO: Case where $seen is empty (see above)
        seen=$(git rev-parse --quiet --verify AURUTILS_SEEN)

        # directory was inspected at a previous time
        if [[ $seen != "$(git rev-parse HEAD)" ]]; then
            # contents have changed since last inspection
            if (( verbose )); then
                git --no-pager log --patch --stat "$seen..HEAD"
            fi

            if [[ $log_dir ]]; then
                git --no-pager log --patch --stat "$seen..HEAD" >"$log_dir/$pkg".diff
            fi
        fi
    fi

    # clean up variables
    unset GIT_DIR GIT_WORK_TREE
done

# vim: set et sw=4 sts=4 ft=sh:
